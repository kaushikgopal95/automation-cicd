pipeline {
  agent any
  environment {
    AWS_ACCOUNT_ID = 'your-aws-account-id'
    AWS_REGION = 'us-east-1'
    ECR_REGISTRY = '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com'
    IMAGE_NAME = 'plantbot'
    ECS_CLUSTER = 'plantbot-cluster'
    ECS_STAGING_SERVICE = 'plantbot-staging'
    ECS_PRODUCTION_SERVICE = 'plantbot-production'
    AWS_STAGING_URL = 'https://your-staging-domain.com' // Update with your staging domain
    AWS_PRODUCTION_URL = 'https://your-production-domain.com' // Update with your production domain
  }
  
  stages {
    stage('Build and Push Staging Image') {
      steps {
        script {
          // Build staging image
          sh "docker build --target staging -t ${ECR_REGISTRY}/${IMAGE_NAME}:staging ."
          
          // Login to ECR
          sh "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}"
          
          // Push to ECR
          sh "docker push ${ECR_REGISTRY}/${IMAGE_NAME}:staging"
          
          echo "Staging image built and pushed to ECR"
        }
      }
    }
    
    stage('Deploy to AWS Staging') {
      steps {
        script {
          // Update ECS service with new image
          sh "aws ecs update-service --cluster ${ECS_CLUSTER} --service ${ECS_STAGING_SERVICE} --force-new-deployment"
          
          // Wait for service to be stable
          sh "aws ecs wait services-stable --cluster ${ECS_CLUSTER} --services ${ECS_STAGING_SERVICE}"
          
          // Wait for staging to be healthy
          sh "node scripts/wait-for-healthy.js ${AWS_STAGING_URL} 300"
          
          echo "AWS staging deployment completed and healthy"
        }
      }
    }
    
    stage('Run Cypress Tests on AWS Staging') {
      steps {
        script {
          // Run Cypress tests against the live AWS staging URL
          sh "CYPRESS_BASE_URL=${AWS_STAGING_URL} npx cypress run"
        }
      }
      post {
        always {
          archiveArtifacts artifacts: 'cypress/videos/**/*,cypress/screenshots/**/*'
        }
      }
    }
    
    stage('Build and Push Production Image') {
      when {
        expression { currentBuild.result == 'SUCCESS' }
      }
      steps {
        script {
          // Build production image
          sh "docker build --target production -t ${ECR_REGISTRY}/${IMAGE_NAME}:production ."
          
          // Login to ECR
          sh "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}"
          
          // Push to ECR
          sh "docker push ${ECR_REGISTRY}/${IMAGE_NAME}:production"
          
          echo "Production image built and pushed to ECR"
        }
      }
    }
    
    stage('Deploy to AWS Production') {
      when {
        expression { currentBuild.result == 'SUCCESS' }
      }
      steps {
        script {
          // Update ECS service with new image
          sh "aws ecs update-service --cluster ${ECS_CLUSTER} --service ${ECS_PRODUCTION_SERVICE} --force-new-deployment"
          
          // Wait for service to be stable
          sh "aws ecs wait services-stable --cluster ${ECS_CLUSTER} --services ${ECS_PRODUCTION_SERVICE}"
          
          // Wait for production to be healthy
          sh "node scripts/wait-for-healthy.js ${AWS_PRODUCTION_URL} 300"
          
          echo "AWS production deployment completed and healthy"
        }
      }
    }
  }
}