# Automation CICD Project

## Overview
This project demonstrates a full CI/CD pipeline for a web application using Docker, Jenkins, Cypress, and AWS. It is designed to help beginners and QA engineers understand how modern automation and deployment workflows work.

---

## Project Structure: What Belongs Where?

- **Website (Frontend) Code:**
  - `src/` — All your website source code (React, CSS, components, etc.)
  - `public/` — Static assets for the website (favicon, robots.txt, etc.)
  - `index.html`, `App.tsx`, etc. — Main entry points for the web app
- **Cypress Tests:**
  - `cypress/` — Contains all Cypress end-to-end and component tests
- **CI/CD & Automation:**
  - `Dockerfile` — Multi-stage build for dev, staging, and production
  - `docker-compose.dev.yml` — For local development
  - `docker-compose.qa.yml` — For QA/staging automation and Cypress tests
  - `docker-compose.prod.yml` — For production deployment
  - `Dockerfile.jenkins` — Custom Jenkins image with Docker CLI/Compose
  - `docker-compose.jenkins.yml` — Runs Jenkins as a container
  - `jenkinsfile` — Defines the CI/CD pipeline steps
- **Configuration & Meta:**
  - `package.json` — Lists project dependencies, scripts, and metadata
  - `package-lock.json` — Locks exact dependency versions for reproducible installs
  - `README.md` — This documentation

---

## What is `package.json` and `package-lock.json`?

- **package.json:**
  - Describes your project (name, version, scripts, dependencies, etc.)
  - Used by npm/yarn to install and manage packages
- **package-lock.json:**
  - Automatically generated by npm
  - Records the exact versions of every installed package (and their dependencies)
  - Ensures everyone installs the same versions, making builds reproducible

---

## Why Use Ubuntu WSL2 for Jenkins & Docker on Windows?

- **Why:**
  - Docker and Linux-based tools (like Jenkins in a container) work best in a real Linux environment.
  - Windows file permissions and Docker socket access can cause issues with advanced CI/CD.
  - WSL2 (Windows Subsystem for Linux 2) gives you a real Linux environment inside Windows, solving these problems.
- **Is it common?**
  - Yes! Most professional teams on Windows use WSL2 for Docker-based development and CI/CD.
- **How to install:**
  1. Open PowerShell as Administrator and run:
     ```sh
     wsl --install
     ```
  2. Restart your computer if prompted.
  3. Open Ubuntu from the Start menu and finish setup.
  4. Install Docker Desktop for Windows and enable WSL2 integration in Docker settings.
  5. In Ubuntu (WSL2), test Docker with:
```sh
     docker --version
     docker run hello-world
     ```

---

## CI/CD Flow: Step-by-Step with Visual Diagram

### **1. Developer Workflow**
- Developer writes code and pushes to the `staging` branch.

### **2. Jenkins Pipeline (CI/CD)**
- Jenkins (running in WSL2) detects the push and starts the pipeline:
  1. **Build Staging Image (Optional):** Builds the Docker image for QA/staging.
  2. **Deploy to AWS Staging:** SSH into the AWS staging server, pulls the latest code, and runs `docker-compose.qa.yml` to deploy the app.
  3. **Run Playwright Tests on AWS Staging:** Runs Playwright tests against the live staging URL (e.g., `https://your-staging-aws-url.com`).
  4. **If tests pass:**
     - Manual PR/merge from `staging` to `main` (production) branch.
  5. **Deploy to AWS Production:** Jenkins SSHs into the AWS production server and runs `docker-compose.prod.yml` to deploy the app live.

### **Visual Diagram**

```
[Dev pushes to staging]
        |
        v
[Jenkins pipeline starts]
        |
        v
[Build staging Docker image (optional)]
        |
        v
[Deploy to AWS staging via SSH & docker-compose.qa.yml]
        |
        v
[Run Playwright tests on live AWS staging URL]
        |
        v
[Tests pass?] --No--> [Fix code and push again] --|
        |                                        |
       Yes                                       |
        v                                        |
[Manual PR/merge to main branch] <---------------|
        |
        v
[Jenkins pipeline for main branch]
        |
        v
[Deploy to AWS production via SSH & docker-compose.prod.yml]
```

---

## Example Jenkinsfile (Simplified)

```groovy
pipeline {
  agent any
  stages {
    stage('Build Staging Image (Optional)') {
      steps {
        sh 'docker-compose -f docker-compose.qa.yml build'
      }
    }
    stage('Deploy to AWS Staging') {
      steps {
        sh 'ssh ec2-user@your-aws-staging-server "cd /path/to/app && git pull && docker-compose -f docker-compose.qa.yml up -d --build"'
      }
    }
    stage('Run Playwright Tests on AWS Staging') {
      steps {
        sh 'npx playwright test --base-url=https://your-staging-aws-url.com'
      }
      post {
        always {
          archiveArtifacts artifacts: 'playwright-report/**/*'
        }
      }
    }
    stage('Deploy to AWS Production') {
      when {
        expression { currentBuild.result == 'SUCCESS' }
      }
      steps {
        sh 'ssh ec2-user@your-aws-production-server "cd /path/to/app && git pull && docker-compose -f docker-compose.prod.yml up -d --build"'
      }
    }
  }
}
```

---

## Key Takeaways
- All environments (dev, staging, prod) use Docker and Docker Compose for consistency.
- Jenkins and Docker run in Ubuntu WSL2 on Windows for best compatibility.
- Playwright tests run against the actual deployed staging environment (not localhost).
- No Docker registry is used for now; images are built on the server.
- Netlify is not used; AWS hosts both staging and production.

---

## Troubleshooting & Tips
- If Docker commands fail in WSL2, make sure your user is in the `docker` group:
  ```sh
  sudo usermod -aG docker $USER
  exec $SHELL -l
  ```
- Always run Jenkins and Docker Compose commands from Ubuntu (WSL2), not Windows PowerShell.
- Use clear branch names (`staging`, `main`) and protect your main branch with required status checks.

---


